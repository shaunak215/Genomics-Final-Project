# Wheeler_Graph

## Group member contribution
|            | Eduardo Aguila | Shaunak Shah | Kuan-Hao Chao | Beril Erdogdu |
------------ | -------------- | ------------ | ------------- |-------------- |
Coding       |  |  | recognizer | Pattern matcher |
Deliverables |  |  | recognizer | Pattern matcher |


## Recognizer

WG recognizing problem is hard. It is proved NP-complete by Gibney and Thankachan in 2019, and the time complexity of the pseudocode algorithm is <img src="https://render.githubusercontent.com/render/math?math=2^{e \cdot log\sigma  %2B O(n  %2B e)}">.
We implemented a faster recognizer in C++, and it is a factorial algorithm doing minimum permutations. Given a directed graph G with edge labels and random node labels in DOT format, the recognizer answers whether G is a wheeler graph or not and outputs the WG data structure proposed by Gagie (2017). 


### 1. Building the latest version from `src/`

```
cd ./recognizer/src/

make
```

### 2. Running recognizer


```
Usage:

   recognizer  <in.dot>  [wg_recognizer_method]  [stop_condition]  [print_invalid]
```

```
Options:

   wg_recognizer_method : the recognizer algorithm. 'm1' is the exponential algorithm; 
                          'm2' is the one scan through algorithm (still under development)
                          'm1' or 'm2'. The default is 'm1'.
  
   stop_condition       : whether to find one set of node labels and stop or all sets of correct node labels.
                          'early_stop' or 'normal'. The default is 'early_stop'.
                         
   print_invalid        : whether to print out the invalid wheeler graph log during node labels permutation. 
                          '0' or '1'. The default is '0'.
```

### 3. Inputs and outputs:
The recognizer takes any DOT file as the input and test whether at least one set of correct node labels can be generated. In this WG suite of tools, it takes the DOT file generated by generator. If it is not a WG, program halts and nothing is outputted; if it is a wheeler, then five files are generated. Following are the description:

1. `I.txt`:  the I bitarray (indegree) of Gagie's WG data structure.
2. `O.txt`:  the O bitarray (outdegree) of Gagie's WG data structure.
3. `L.txt`:  the L array of Gagie's WG data structure.. Itâ€™s the concatenation of corresponding edges labels of nodes in O bit array.
4. `node.dot`: the mapping from old node labels to new node labels.  
5. `graph.dot`: the new, correct, and sorted dot file with new node labels. 


### 4. Reproducible example:

Take `../graph/generator_DOT/node_num_5/after_shuffle/test_1.dot` DOT file as an example. It is a random valid WG outputted by the generator, and recognizer takes it as the input.

```
DOT file path:  ./recognizer/graph/generator_DOT/node_num_5/after_shuffle/test_1.dot

   strict digraph  {
   S1;
   S0;
   S5;
   S3;
   S6;
   S2;
   S4;
   S5 -> S0  [label=a];
   S5 -> S6  [label=a];
   S5 -> S4  [label=b];
   S3 -> S4  [label=b];
   S4 -> S6  [label=a];
   }
 ```
  
Run the following command:

```
cd ./recognizer/src/

./recognizer  ../graph/generator_DOT/node_num_5/after_shuffle/test_1.dot m1 early_stop 1
```

You will get the following five output files:

1. ***I.txt***:
   ```
    1101001001
   ```
2. ***O.txt***:
   ```
    0100011101
   ```
3. ***L.txt***:
   ```
    baaba
   ```
4. ***node.dot***:
   ```
    S3	1
    S5	2
    S0	3
    S6	4
    S4	5
   ```
5. ***graph.dot***:
   ```
    strict digraph  {
    2 -> 3 [label=a];
    2 -> 4 [label=a];
    5 -> 4 [label=a];
    1 -> 5 [label=b];
    2 -> 5 [label=b];
    }
   ```
